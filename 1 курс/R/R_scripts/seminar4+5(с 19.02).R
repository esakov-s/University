{
	# Задание 1
	w <- c(123, 4L, TRUE)
	typeof(w)
	mode(w)
	str(w)
	#mode представляет более общую информацию о типе элементов векторов(вместо double numeric)
	# во отличие от typeof
	# str выводит полную инфрмацию о векторе : типа данных, диапазон нумерации ячеек и их значения	
}

{
	# Задание 2
	w1 <- c(-12L, 4, 'Level 2', 8.2, TRUE)
	w2 <- c(0, 56 / 6, FALSE, FALSE, 18)
	w3 <- c(Inf, NULL, NA, FALSE, 18, NaN)
	w4 <- c(Inf, NULL, NA, FALSE, 18L, NaN)
	w5 <- c(Inf, NULL, NA, FALSE, '18', NaN)
	w6 <- c(NULL)
	typeof(w1)
	length(w1)
	typeof(w2)
	length(w2)
	typeof(w3)
	length(w3)
	typeof(w4)
	length(w4)
	typeof(w5)
	length(w5)
	typeof(w6)
	length(w6)
	# Длины всех векторов кроме последнего - 5, последний размера 0
	# вектора w3 и w4 имеют одинаковый тип(double), так как оба имеют в составе элемент Inf, имеющий тип double
}

{
	# Задание 3
	w1 <- rep(c(0, -1, 1:3), times = 3)
	w2 <- rep(c(0, -1, 1:3), each = 3)
	w3 <- rep(c(0, -1, 1:3), each = 3, times = 2)
	#Параметр times повторяет вектор некоторое число раз, параметр each повторяет каждый элемент указанное число раз
	#each выполняется раньше time
}

{
	# Задание 4
	w <- seq(to = 40, by = 3, length.out = 6)
	#Данная функция генерирует последовательность элементов опираясь на параметры from или to(не оба одновременно)
	#если вектор генерируется с начала(используем параметр from), если с конца(исполузуем параметр to)
	#количество элементов - length.out; интервал между ними - by
}

{
	# Задание 5
	w <- seq_len(1.5)
	#seq_len генерирует последовательнсоть элементов, начинающуюся с единицы  с шагом с количеством элемнтов которое передаётся в функцию ? ???????? ??????????? ????????? 
	#Функция seq(lengt.out = 11) будет аналгична вызову функции seq_len(11).
	#При использовании нецелочисленного параметра seq_len создаст последовательность целых чисел с округлением параметра функции вниз
	#Параметр функции seq-length  не может быть отрицательным
}

{
	#Задание 6
	scan(what = logical())
}


{
	#Задание 7
	z <- scan(what = character(), sep = 'ю')
	z1 <- scan(what = character())
}


{
	#Задание 8
	v1 <- c(2, 7, 4)
	print(v1)
	fix(v1)
	print(v1)
	v2 <- edit(v1)
	#fix меянет сам вектор, edit создаёт копию вектора
}

{
	#Задание 9
	a <- c(7:4, 0)
	b <- c(8, 10.5, 0, -2, 9)
	print(a + b)
	print(a * b)
	print(a / b)
	print(paste(mean(a), mean(b)))
	print(paste0(sum(a), " --- ", sum(b)))
	#Все арифметические операции выполняются поэлементно
}

{
	#Задание 10
	c <- c(3L, 'asign')
	typeof(c)
	#Если есть хоть один character, то тип вектора будет сharacter
	#(иначе) если хоть один элемент типа double, то тип вектора будет double
	#то есть последовательность типов при преобразовании такова : logical -> integer -> double -> character 
}

{
	#Задание 11
	v1 <- c(4L, 2L, 3L)
	v2 <- c(2L, 7L, 11L, 15L)
	v3 <- c(4L, 3L, 1L)
	v4 <- c(TRUE, FALSE, FALSE, TRUE)
	v5 <- c(TRUE, TRUE, FALSE)
	print(paste("Один тип, один размер", v1 + v3))
	print(paste("Один тип, разный размер", v1 + v2))
	print(paste("Разный тип, один размер", v1 + v5))
	print(paste("Разный тип, разный размер", v1 + v4))
	#При сложении(или другой операции) веторов разных типов выполняется правило преобразования типов (как и для обычных переменных)
	#Если вектора разного размера, то операции также будут выполняться поэлементно, 
	#при этом меньший вектор будет дополняться элементами из начала этого же вектора, пока длины векторов не станут равны
	#(возможно меньший вектор будет повторён такми образом несколько раз)
}

{
	#Задание 12 !!!
	a <- c(2, 5, 2.5)
	b <- c('a', 'cw')
	c <- c(T, F, F)
	d <- c(2:6)
	e <- c(1 + 7i, 2 - i)
	print(a | b)
}

{
	#Задание 13
	v <- round((runif(n = 100) * 46) - 17)
	print(sort(v))
}

{
	#Задание 14
	v <- sample(x = seq(from = 1, to = 1000, by = 0.01), size = 200) / 1000 * 5 - 7
	print(sort(round(v, 3)))
}


{
	#Задание 15
	w <- scan(what = character(), sep = '\n')
	#Функция scan считывает из командной строки 
	#Парметр sep определяет по какому символу разделять вводиму строку (по умолчанию пробел)
	#Может быть только однобайтного размера (один символ)
}

{
	#Задание 16
	w1 <- -3.3:4.67
	w2 <- rep(c(1:-2), 3)
	w3 <- w1 ^ w2
	print(w3)
	#Элементы вектора w3  - результат поэлементного возведения элементов вектора w1  в степень соответствующих элементов вектора w2
	#Так как w2 имеет 12 элементов, а w1 - 8, дополнительные элементы берутся из начала вектора w1 (по правилу из номера 11)

}

{
	#Задание 17  
	rus_lib <- c('а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я')
	rus_lib <- c(rus_lib, toupper(rus_lib))

	n <- readline("Введите n: ")
	print(length(rus_lib))
	rand <- sample(66, n, replace = TRUE)
	txt <- c(rus_lib[rand])
	print(txt)
}

{
	#Задание 18
	# sort формирует список объектов и сортирует сами объекты
	# order формирует массив индексов, которые опрделяют порядок элементов (по умолчанию в порядке возрастания)
}

{
	#Задание 19
	a <- scan(what = integer())
	b <- scan(what = integer())
	z = c(a %% b | b %% a)
	print(z)
}

{
	#Задание 20

}
